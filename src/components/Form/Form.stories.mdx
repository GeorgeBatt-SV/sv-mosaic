import { Meta, Story, Preview } from '@storybook/addon-docs/blocks';

<Meta title='Components/Form/Readme' />

# Form
"Forms" was born as a solution to help all SimpleView products currently using MOSAIC standardize both styling and functionality
of all forms.

The form component comes pre-filled with multiple generic stylished and functional fields so you can focus on your app's
functionality and not how to make a form work.

## Props
* **state** - `any` required - Object which will contain all filled fields and their corresponding value.
* **title** - `string` optional - Title of the form.
* **fields** - `FieldDef[]` required - Array of fields containing their respective configuration (see [Generic Field Props subsection](#generic-field-props-fielddef)).
* **sections** - `SectionDef[]` optional - Object containing all the configuration for every section of the form, including the layout in which fields will render. When no sections get passed fields will render 1 per row (see [SectionDef subsection](#sectiondef)).
* **dispatch** - `any` required - Function in charge of updating the state (see [Dispatch Actions subsection](#dispatch)).
* **dialogOpen** - `boolean` optional - When true, this flag will render a dialog with the message "You have unsaved changes. If you leave all your changes will be lost." This only works when the prop type = "drawer".
* **description** - `string` optional - Additional text that will render under the title.
* **getFormValues** - `() => Promise<MosaicObject>` optional - Function that will run once the form renders to prepopulate the fields. This should return an object where the key is the name of the field, and the value is the value to prepopulate the field.
* **buttons** - `ButtonAttrs` optional - Array of buttons that will be rendered at the TopComponent. Each button object can be configured based on the button's props (see [ButtonAttrs type](#buttonattrs-type) and [ActionAdditional type](#actionadditional-type) `['show']`).
* **handleDialogClose** - `(val: boolean) => void` optional - Function that will get called when closing the dialog (see explanaition of the dialogOpen prop).
* **onBack** - `(() => void) | ((...args: any) => void)` - optional - Callback used to go back to the previous screen / element / drawer. When passed a left arrow will render to the left of the title.
* **useSectionHash** - `string | false` - optional - The string that should be used to prefix the section index in the URL hash when scrolling. Provide `false` to disable the URL hash mechanic entirely.

## useForm Hook
- In order to create and work with the `Form` component it's required to create an instance of the useForm hook per form.
- This hook returns a state and a dispatcher, which will be explained in the following subsections.

```ts
// We recommend placing the useForm hook at the top of your component.
const App = (props) => {
	const { state, dispatch } = useForm;

	//...rest of App.tsx
}
```
### State
The state is an object that contains the following structure:
* **data** - `object` - Contains a key-value pair of all fields that have a value, for example: "myTextField": "my value".
* **errors** - `object` - Contains a key-value pair of all fields that have an error message, for example: "myTextField": "This field is required, please fill it".
* **validating** - `object` - Contains a key-value pair of all fields that are undergoing validation. All validations are run when executing an onBlur per field or when clicking on the save button.
* **validForm** - `boolean` - Flag that indicates whether the field is valid or not, this is affected by the errors object".
* **disabled** - `boolean` - Flag that indicates whether the field is disabled or not. By default, everytime the user clicks on the save button a whole form validation gets executed which disables the form during this process, although depending on the amount of fields this happens extremely fast.

### Dispatch
The dispatch function allows developers to update the state through the following formActions:
* **init** - `({fields}) => Promise<void>` - This action registers the fields internally so the Form builder can process their data.
	* **name** - init.
	* **arguments** - `object`
		* **fields** - `FieldDef[]` - Object containing all fields and their definition (see [Generic Field Props subsection](#generic-field-props-fielddef)).
	* **return** - `Promise<void>`
* **setFieldValue** - `({name, value, validate = false}) => Promise<void>` - This action updates the value of the field passed. By default this action gets called when an onChange occurs per field.
	* **name** - setFieldValue
	* **arguments** - `object`
		* **name** - `string` - Name of the field.
		* **value** - `string` - Value to assign to the field.
		* **validate** - `boolean` - Whether the field should be validated when finishing executing the onChange.
	* **return** - `Promise<void>`
* **validateField** - `({name}) => Promise<void>` - This action validates the field passed. By default this action gets called when onBlur
	* **name** - validateField
		* **arguments** - `object`
			* **name** - `string` - Name of the field.
		* **return** - `Promise<void>`
* **validateForm** - `({fields}) => Promise<void>` - This action validates the entire form.
	* **name** - validateForm
	* **arguments** - `object`
		* **fields** - `FieldDef[]` - Object containing all fields and their definition (see [Generic Field Props subsection](#generic-field-props-fielddef)).
	* **return** - `Promise<void>`
* **submitForm** - `() => Promise<{valid, data}>` - This action validates the entire form (calls the action validateForm) and returns the valid value and the form's data (json with names and values of all fields) at that point in time.
	* **name** - submitForm
	* **arguments** - `none`
	* **return** - `Promise<{valid: boolean, data: any}>`
* **resetForm** - `() => Promise<void>` - This action completely empties the state.
	* **name** - resetForm
	* **arguments** - `none`
	* **return** - `Promise<void>`
* **setFormValues** - `({values}) => Promise<void>` - This action prepopulates the fields with the values being passed.
	* **name** - setFormValues
	* **arguments** - `object`
		* **values** - `MosaicObject` - Object containing all fields and their values.
	* **return** - `Promise<void>`

```ts
import { formActions } from "sv-mosaic";

const App = (props) => {
	const updateValueExample = async () => {
		await dispatch(
			formActions.name(arguments)
		);
	}
	//...rest of App
}
```

### Submit
How the form submission process will be executed is responsible for who is instantiating a Form component and also the definition of the button that will trigger it.
The submit function should dispatch a form action of type submitForm that will return if the form is valid and also its data which could be handled in any way during the submit process.
Take a look at the [How to create a form?](#how-to-create-a-form) section for more details.

```ts
const onSubmit = useCallback(async () => {
		const { valid, data } = await dispatch(formActions.submitForm());
		if (!valid) return;

		// DO SOMETHING WITH THE DATA
	}, [dispatch]);

const buttons: ButtonProps[] = [
		{
			label: "Save",
			onClick: onSubmit,
			color: "yellow",
			variant: "contained"
		},
];
```

## Layout
- By default all Forms are created as one big section made of multiple rows (one per field), and one column per row (containing the field).
- This setting can be overwritten by adding a sections array (see [Sections subsection](#sections)).

### Sections
Sections follow the next set of rules:
* Can have a title and a description.
* Each section can have multiple rows.
* Each column can have as many fields as needed.

#### SectionDef
| Name | Type | Description |
| ---- | ---- | ----------- |
| **`title`** | `string` | optional - Text that helps users identify the section. This is also used when rendering tabs to scroll the user to the selected section. |
| **`description`** | `string` or `JSX.Element` | optional - Additional text that allows users to understand the purpose or instructions of a section better. |
| **`fields`** | `MosaicGridConfig` | required - Structure that serves as a map to position fields across rows and columns. Each section can have multiple rows, each row multiple columns, and each column multiple fields ([rows][columns][fields]) |
| **`collapsed`** | `boolean` | optional - Allows developers to decide whether the section will be first rendered collapsed or expanded. It defaults to false when no value is provided. |
| **`show`** | [`MosaicToggle`](#MosaicToggle-t-type) | optional - Show callbacks will be called with `{data: formState.data}` |

## How to create a form?
```ts
import { Form, useForm, formActions } from "sv-mosaic";

const App = (props) => {
	const { state, dispatch } = useForm;

	//...rest of App.tsx
	const fields = useMemo(
		() =>
			[
				{
					name: "myTextField",
					type: "text",
				},
				{
					name: "myCheckboxField",
					type: "checkbox",
				},
				//...all other fields
			],
			[]
	);

	// If you want to create a section and include it into the
	// Form check how is done in the Layout - Sections section.

	const onLoad = useCallback(async () => {
		//Get values from the DB to prepopulate fields
		const values = await callDB();

		return values;
	});

	const onSubmit = useCallback(async () => {
		const { valid, data } = await dispatch(formActions.submitForm());
		if (!valid) return;

		// DO SOMETHING WITH THE DATA
	}, [dispatch]);

	const buttons: ButtonProps[] = [
		{
			label: "Save",
			onClick: onSubmit,
			color: "yellow",
			variant: "contained"
		},
		{
			label: "Cancel",
			onClick: () => { /** Cancel logic **/ },
			color: "gray",
			variant: "outlined"
		},
	];

	return (
		<Form
			buttons={buttons}
			title="My Form"
			description="This is a description example"
			state={state}
			fields={fields}
			dispatch={dispatch}
			getFormValues={onLoad}
		/>
	);
}
```

## Data
The Fields and the Form are in constant communication and exchange data. In order to maintain consistency, all fields and ways of updating data obey the following contract.
```ts
{
	"nameOfField1": "Value of field1",
	"nameOfField2": "Value of field2",
	...
	"nameOfFieldN": "Value of fieldN",
}
```
The key of each element allows the form to know which field to work with and what's its value.

This is used in the same way in the following moments:
1. When updating the state (see data attribute on [State](#state)) through an action (see [Dispatch](#dispatch)).
2. During an onChange of a field.
3. When prepopulating a field or an entire form (see getFormValues prop on [Props](#props)).
4. When assigning a defaultValue to a field.

### How to use on a form?
```ts
//Scenario 1
const updateValues = async () => {
	await dispatch(
		formActions.setFieldValue({name: "myField", value: "myValue"})
	);

	//State will look like this:
	// { data: { "myField": "myValue" }}
}

//Scenario 2 can only be seen when executing an onChange on a field.

//Scenario 3
const getValuesFromDB = async () => {
	const res = await callToDb();
	//res = { "myField": "myValue" }
	return res;
}

<Form
	//...all other props
	getFormValues={getValuesFromDB}
/>

//Scenario 4
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				name: "myField",
				type: "text",
				defaultVaue: "myValue"
			},
			//...other fields
		],
	[]
);
```

## Form Fields
- All fields share a series of props that help the form identify and interact with each field.

### Generic Field Props (FieldDef)
* **name** - `string` required - Significant name related to the field. This shouldn't have spaces as it serves as an identifier to read and write it's corresponding value.
* **label** - `string | undefined` required - A label to display for the user interacting with the filter.
* **required** - `boolean` optional - Marks if the field should be filled or not.
* **helperText** - `string` optional - Text that gives context to the user as what the field does.
* **instructionText** - `string` optional - Instructions about how to fill the current field.
* **disabled** - `MosaicToggle` optional - Disable callbacks will be called with `{data: data}`
* **inputSettings** - `object` optional - Specific props for each specific field (Please see the Props section of each field).
* **size** - `string` optional - Size of the field. Could be either one of the predefined sizes, or a custom size. This property can be internally overwritten if the field is placed inside of a row with other fields.
	* **xs** = 100px
	* **sm** = 280px
	* **md** = 450px
	* **lg** = 620px
* **className** - `string` optional - Follows the same rules as any other html element className.
* **style** - `object` optional - Follows the same rules as any other html element style.
* **type** - `string | JSX Element | (() => JSX Element)` required - Field that will be rendered. This can be a string (see type of each form field) or a custom component.
* **layout** - `object` optional - Optional object that defines the position of the field within the layout.
	* **section** - `number` optional - Defines the section where the field will appear (begins at 0).
	* **row** - `number` optional - Defines the row where the field will appear (begins at 0).
	* **col** - `number` optional - Defines the column where the field will appear (begins at 0).
* **validators** - `array` of `string | { fn: string; options: any } | (() => string | undefined | JSX Element))` optional - Validators to be executed when an onBlur occurs on the Field or when an onSubmit occurs on the Form (see the [Validators section](#validators) for more information about default and custom validators).
* **id** - `string` optional - Follows the same rules as any other html element id.
* **defaultValue** - `<U>` optional - Value to be used in case no initial value is loaded from a data base. This value should be of the same type as from its corresponding field (see data of each specific field).
* **onChangeCb** - `(value?: any) => void` optional - Callback that will be executed when the field triggers an onChange event.
* **show** - [`MosaicToggle`](#MosaicToggle-t-type) optional - Show callbacks will be called with `{data: data}`

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				name: "myTextField",
				label: "Age",
				required: true,
				helperText: "This is an example of a helper text",
				instructionText: "This is an example of an instruction text",
				disabled: false,
				inputSettings: {}, //Please see inputSettings of each field
				size: "sm",
				className: "myClassName",
				style: {{ marginTop: "5px", }},
				type: "text", //This will vary, please see "How to create in a form?" of each field
				layout: , //Please see Layout section for different ways of arranging fields on the form.
				validators: ["validateNumber"], //Please see validators section on ways of adding validators.
				id: "myId",
				defaultValue: "42", //Plase see data of each field and data section to better understand how fields interact with values.
			},
			{
				name: "myCheckbox",
				//...all other generic field props
			}
			//...other fields
		],
	[]
);
```

## FormFieldAddress
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- Countries, states and cities information retrieved from: [Countries States Cities Database](https://github.com/dr5hn/countries-states-cities-database)
- Features a draw with an embedded "child" form which can be used to create or edit addresses.
- [**Playground**](/?path=/story/formfields-formfieldaddress--playground)
- Data: `object`
	* **address1** - `string` required - Main address.
	* **address2** - `string` optional - Additional address.
	* **address3** - `string` optional - Additional address.
	* **city** - `string` required - Name of the city.
	* **country** - `MosaicLabelValue` required - Object containing the label and value of the country.
	* **postalCode** - `string` required - Postal code of the address.
	* **state** - `MosaicLabelValue` required - Object containing the label and value of the state.
	* **types** - `array` of `string` required - Could be one of the following: Physical, Billing, Shipping.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`amountPerType`** | `number` | optional - When defined, limits the amount of address types. For example: If a dev adds “amountPerType: 2” then users will be able to add 2 physical, 2 billing, and 2 shipping addresses. Defaults to 1 if no other amount properties are defined and 0 otherwise. |
| **`amountShipping`** | `number` | optional - When defined, limits the amount of address type of "shipping". Takes precedence over amountPerType. |
| **`amountPhysical`** | `number` | optional - When defined, limits the amount of address type of "physical". Takes precedence over amountPerType.|
| **`amountBilling`** | `number` | optional - When defined, limits the amount of address type of "billing". Takes precedence over amountPerType. |
| **`getOptionsCountries`** | `(): Promise<MosaicLabelValue[]>` | Required - Returns a list of mapped countries in the shape of label-value array. |
| **`getOptionsStates`** | `(country: string): Promise<MosaicLabelValue[]>` | Given a country value it returns the list of states of the given country in the shape of label-value array. |
| **`googleMapsApiKey`** | `string` | Required - Google Maps API key needed to access Place Autocomplete Google web service that returns place predictions in response to an HTTP request. |

Note that if the amount rules mean that only 1 type of address is allowed, the type field will not appear in the address drawer.

### How to use in a form?
```ts
const getOptionsCountries = async () => {
	const countriesArr: MosaicLabelValue[] = await countriesMicroService();
	return countriesArr;
}

const getOptionsStates = async (country) => {
	const statesArr: MosaicLabelValue[] = await statesMicroService(country);
	return statesArr;
}

const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "address",
				inputSettings: {
					amountPerType: 1,
					amountShipping: 0,
					amountPhysical: 2,
					amountBilling: 3,
					getOptionsCountries,
					getOptionsStates,
					googleMapsApiKey: "ABCDEFG1234567890"
				},
			},
			//...other fields
		],
	[]
);
```
<!-- ### Example
<Preview withSource='none'></Preview> -->


## FormFieldAdvancedSelection
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- Allow users to select one or more options from a modal menu.
- Used for very long lists.
- Have the ability to type and search.
- [**Playground**](/?path=/story/formfields-formfieldadvancedselection--playground)
- Data: `array` of `object` - Array of values of the selected options.
	* **label** - `string` - Text users will see to identify the option.
	* **value** - `string[]` - Value that will be saved to the DB when the option gets selected.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`createNewOption`** | `(newOptionLabel: string) => Promise<MosaicLabelValue>` | optional -  Function used to insert more options either on the local options array, or on the DB. |
| **`options`** | `MosaicLabelValue[]` | required -  Used to set the full info (label, value) of all selected options. This prop only applies when getting options locally. The label is the text the users will see to identify the option and the value will be saved to the DV when the option gets selected. |
| **`getOptions`** | `({filter?: string, limit?: number, offset?: number}) => Promise<MosaicLabelValue[]>` | required - Function to get the next set of options. This prop only applies when getting options from a DB. |
| **`getOptionsLimit`** | `number or string` | optional - When defined, limits the amount of options to get from the DB. This prop only applies when getting options from a DB. |
| **`selectLimit`** | `number` | optional - Defines the maximum amount of options users can select. Passing undefined or not passing it at all allows users to select as many as they want. |

### How to use in a form?
```ts
// List of options
const externalOptions = [
	{
		label: "Option1",
		value: "value1",
	},
	{
		label: "Option2",
		value: "value2",
	}
]

/**
 * Definition of the funtion that enables the
 * creation of new options.
**/
const myCreateOptionFn = async (newOptionLabel) => {
	const value = `${newOptionLabel}_${externalOptions.length}`
	const newOption = {
		value,
		label: newOptionLabel,
	}

	//Insert to db
	externalOptions.push(newOption);

	return newOption;
}

//Option recommended when getting options locally.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "advancedSelection",
				inputSettings: {
					createNewOption: myCreateOptionFn,
					options: externalOptions
				}
			},
			//...other fields
		],
	[]
);

//Option recommended when getting options from a database.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "advancedSelection",
				inputSettings: {
					createNewOption: myCreateOptionFn,
					getOptions: myGetOptionsFn,
					getOptionsLimit: 5,
				}
			},
			//...other fields
		],
	[]
);
```


## FormFieldCheckbox
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- A group of checkbox buttons that allows users to select multiple items from a list of possible options.
- [**Playground**](/?path=/story/formfields-formfieldcheckbox--playground)
- Data: `array` of `string` - Array of values of the selected options.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`options`** | `MosaicLabelValue[]` | required - Array of options to be rendered containing their corresponding label and value. |
| **`getOptions`** | `() => Promise<MosaicLabelValue[]>` | required - Function to get a set of options. This prop only applies when getting options from a DB. |

### How to use in a form?
```ts
//Option recommended when getting options locally.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "checkbox",
				inputSettings: {
					options: [
						{
							label: "Option1",
							value: "value1",
						}
					],
				}
			},
			//...other fields
		],
	[]
);

//Option recommended when getting options from a database.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "checkbox",
				inputSettings: {
					getOptions: myGetOptionsFn,
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldChipSingleSelect
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- The `FormFieldChipSingleSelect` component is built over a wrapper for [MUI Autocomplete](https://mui.com/material-ui/react-autocomplete/#main-content) but with SimpleView brand colors.
- [**Playground**](/?path=/story/formfields-formfieldchipsingleselect--playground)
- Data: `string` - Value of the selected option.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`options`** | `MosaicLabelValue[]` | required - Array of options to be rendered containing their corresponding label, value, and indicator of whether its selected or not. |
| **`getOptions`** | `() => Promise<MosaicLabelValue[]>` |required - Function to get a set of options. This prop only applies when getting options from a DB. |
| **`onSelect`** | `(...args) => void` | optional - Callback to be executed when an option gets selected. |

### How to use in a form?
```ts
//Option recommended when getting options locally.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "chip",
				inputSettings: {
					options: [
						{
							label: "Option1",
							value: "value1",
						},
						{
							label: "Option2",
							value: "value2",
						}
					],
				}
			},
			//...other fields
		],
	[]
);

//Option recommended when getting options from a database.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "chip",
				inputSettings: {
					getOptions: myGetOptionsFn,
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldColorPicker
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- The color picker component allows users to select from pre-defined colors (swatches) or custom colors using a HSB selection interface.
- The implementation of this component is based on the following package: [React Color](https://casesandberg.github.io/react-color/)
- [**Playground**](/?path=/story/formfields-formfieldcolorpicker--playground)
- Data: `string` - Text that represents the hex value of the color picker.
- inputSettings: This component doesn't require any additional props.


### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "color",
			},
			//...other fields
		],
	[]
);
```

## FormFieldDateField
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- It allows the user to view and pick dates from a calendar widget or manually type the date in the text field.
- [**Playground**](/?path=/story/formfields-formfielddatefield--playground)
- Data: `string` - Date in UTC format transformed to string.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`showTime`** | `boolean` | optional - When true a time field will appear next to the date field. |
| **`minDate`** | `Date` | optional - The minimum date that can be chosen using the datepicker or entered into the input. Defaults to 01/01/1900. If used in a form component, will automatically register a minimum date validator |
| **`maxDate`** | `Date` | optional - The maximum date that can be chosen using the datepicker or entered into the input. If used in a form component, will automatically register a minimum date validator |

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "date",
				inputSettings: {
					showTime: false,
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldTimeField
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- It allows the user to view and pick a time from a calendar widget or manually type the time in the text field.
- [**Playground**](/?path=/story/formfields-formfieldtimefield--playground)
- Data: `string` - Time in `HH:MM` 24 hour format.
- This field accepts no inputSettings

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "time",
			},
			//...other fields
		],
	[]
);
```

## FormFieldRadio
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- A group of radio buttons allows users to select a single item from a list of possible options.
- All possible options are exposed up front for comparison.
- Users can only make a single selection from the list of possible options.
- [**Playground**](/?path=/story/formfields-formfieldradio--playground)
- Data: `string` - Value of the selected option.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`options`** | `MosaicLabelValue[]` | required - Predefined set of mutually exclusive options. |
| **`getOptions`** | `() => Promise<MosaicLabelValue[]>` | required - Function to get a set of options. This prop only applies when getting options from a DB. |


### How to use in a form?
```ts
//Option recommended when getting options locally.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "radio",
				inputSettings: {
					options: [
						{
							label: "Label 1",
							value: "label_1",
						},
						{
							label: "Label 2",
							value: "label_2",
						},
						{
							label: "Label 3",
							value: "label_3",
						},
					],
				}
			},
			//...other fields
		],
	[]
);

//Option recommended when getting options from a database.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "radio",
				inputSettings: {
					getOptions: myGetOptionsFn,
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldRaw
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

This type of field will render the corresponding `value` as-is. It can be used to render anything that is a valid `ReactNode` while maintaining the normal field display behaviour, like the label and field hint. It has no `inputSettings`.


### How to use in a form?
```ts

function RawValue() {
	return (
		<RawValueWrapper>
			Lorem ipsum dolor sit amet, consectetur adipiscing elit.
		</RawValueWrapper>
	)
}

async function getFormValues() {
	return {
		raw: <RawValue />
	}
}

const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "raw",
			},
			//...other fields
		],
	[]
);

```

## FormFieldText
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- Text input fields are used to enter text information, numbers, email addresses, or passwords.
- A text field consists of a label and a line with variations in width.
- [**Playground**](/?path=/story/formfields-formfieldtext--playground)
- Data: `string | number` - Value of the input typed.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`maxCharacters`** | `number` | optional - Defines the limit of characters that are allow to type in the input element. |
| **`multiline`** | `boolean` |optional - When is enabled the text field will expand its height.
| **`placeholder`** | `string` | optional - The hint displayed in the input before the user enters a value. |
| **`prefixElement`** | `JSX.Element` | optional - Icon at the beginning of the text field. |
| **`type`** | `string` | optional - Type of the input element. It should be a [valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types). |
| **`maxRows`** | `number` | optional - Maximum number of rows to display when multiline options is set to true. |
| **`minRows`** | `number` | optional - Minimum number of rows to display when multiline option is set to true. |

### How to use in a form?
```ts
const fields: FieldDef[] = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "text",
				size: "md",
				inputSettings: {
					prefixElement: <AccountCircle />,
					maxCharacters: 20,
					placeholder: "placeholder",
					multiline: true,
					maxRows: 4,
					minRows: 3
				},
			},
			//...other fields
		],
	[]
);
```

## FormFieldTextEditor
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- The text editor is a text area with added capabilities for use in various publishers, allowing the users to format their input in a text area.
- This implementation is based on the [Jodit WYSIWYG Editor](https://www.npmjs.com/package/jodit) package.
- [**Playground**](/?path=/story/formfields-formfieldtexteditor--playground)
- Data: `string` - Value of the input typed.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`direction`** | `"rtl" | "ltr" | ""` | optional - Defines the starting point at which the typed words will be displayed, "lrt" starts from the left moving to the right and "rlt" vice versa. Default is "rlt". |
| **`language`** | `string` | optional - Defines the language in which the assistive elements of the text editor will be displayed. For example the placeholder and the character and word counter. |
| **`maxCharacters`** | `number` | optional - Defines the limit of characters that are allow to type in the input element. |
| **`spellcheck`** | `boolean` | optional - If it's enabled the text editor will mark misspellings. |

### How to use in a form?

```ts
const fields: FieldDef[] = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props
				type: "textEditor",
				inputSettings: {
					spellcheck: true,
					direction: "rlt",
					language: "en",
					maxCharacters: 20,
				},
			},
			//...other fields
		],
	[]
);
```

## FormFieldToggleSwitch
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- Toggle Switch allow users to switch between two possible states. They are commonly used to turn a specific setting on or off
- Toggles should be used to turn on or off a preference, notification, or feature
- Should be used when an instant response is required/desired
- [**Playground**](/?path=/story/formfields-formfieldtoggleswitch--playground)
- Data: `boolean` - Defines whether the switch is checked or not.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`toggleLabel`** | `string` | optional - This label is placed at the right of the switch. |

### How to use in a form?

```ts
const fields: FieldDef[] = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props
				type: "toggleSwitch",
				inputSettings: {
					toggleLabel: "Toggle label"
				},
			},
			//...other fields
		],
	[]
);
```

## FormFieldUpload
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- The FormFieldUpload component allows users to upload multiple files of any type.
- [**Playground**](/?path=/story/formfields-formfieldupload--playground)
- Data: `array` of `UploadData`:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`id`** | <code>string &#124; number</code> | required - A unique identifier, used as React "key" |
| **`name`** | <code>string</code> | required - The name of the file, which will be rendered as the file title |
| **`fileUrl`** | <code>string</code> | The URL to the uploaded file which the uploaded item's image and title will link to |
| **`thumbnailUrl`** | <code>string</code> | The URL of the thumbnail that should be displayed. |
| **`downloadUrl`** | <code>string</code> | The downloadable URL of the file, it should respond with a Content-Disposition: attachment header |
| **`downloadStrategy`** | <code>"anchor" &#124; "iframe"</code> | How the file download button should behave:<br />"anchor" - renders an anchor tag with the "download" attribute<br />"iframe" - creates an iframe and navigates to the downloadUrl, then removes the iframe once loaded (or errored)<br />If this property is omitted, the downloadStrategy will be "anchor" if no downloadUrl is provided, or "iframe" if it is. |
| **`size`** | <code>number</code> | The numerical size of the file in bytes |

- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`onFileAdd`** | `(addedData: OnFileAddData) => Promise<void>` | required - Callback function executed per uploaded file.<br /><br />If an error is thrown in this callback, its message will be displayed for the uploaded item |
| **`onFileDelete`** | `({id: string or number}) => Promise<void>` | required - Callback function executed when the user deletes an uploaded file. |
| **`limit`** | `number` | optional - Limits the amount of files users can upload. If not passed users can add as many files as needed. |
| **`accept`** | `string[]` | optional - Limits the types of files that can be uploaded by extension. |
| **`maxFileSize`** | `number` | optional - Limits the size of individual uploads in bytes |
| **`maxTotalSize`** | `number` | optional - Limits the size of all uploads for this field combined in bytes |

- OnFileAddData:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`file`** | `File` | required - File uploaded by the user. |
| **`onChunkComplete`** | `({percent: number}) => Promise<void>` | required - Callback function that allows the file cards to update their progress spinner. The expected percent should be a value between 0 and 1. |
| **`onUploadComplete`** | `(data: UploadData) => Promise<void>` | required - Callback function that allows the component to update the file cards with the newest data |
| ❌ **`onError`** | `(message: string) => Promise<void>` | required - Callback function that allows the file cards to update their style and error message.<br /><br />**DEPRECATED** - Throw an error within `onFileAdd` callback instead. |

### How to use in a form?

```ts
const onFileAdd = async ({file, onChunkComplete, onUploadComplete, onError}) => {
	for (let i = 0; i < 10; i++) {
		await new Promise(resolve => setTimeout(() =>
			resolve(
				onChunkComplete({percent: (i + 1) * 0.1})
			), 300)
		);
	}

	if (Math.random() < 0.3) {
		await onError("File size exceeded");
		return;
	}

	await onUploadComplete({
		id: nanoid(),
		name: file.name,
		size: `${file.size} bytes`,
		url: Math.random() < 0.7 ? URL.createObjectURL(file) : undefined
	});
};

const onFileDelete = ({id}) => {
	alert("DELETED FILE: " + id);
}

const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props
				type: "upload",
				inputSettings: {
					onFileAdd,
					onFileDelete,
					limit: 2,
				},
			},
			//...other fields
		],
	[]
);
```

## FormFieldDropdownSingleSelection
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- `Dropdown Single Selection` is a simple wrapper for [MUI Autocomplete](https://mui.com/material-ui/react-autocomplete/#main-content) but with our brand colors.
- [**Playground**](/?path=/docs/formfields-formfielddropdownsingleselection--playground)
- Data: `string` - String of the selected option.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`placeholder`** | `string` | Optional - Example text shown inside of the text field portion of the dropdown. |
| **`options`** | `MosaicLabelValue[]` | required - Array of options to be displayed on the options. |
| **`getOptions`** | `() => Promise<MosaicLabelValue[]>` | required - Function to get a set of options. This prop only applies when getting options from a DB. |

### How to use in a form?
```ts
//Option recommended when getting options locally.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "dropdown",
				inputSettings: {
					options: [
						{ label: "The Shawshank Redemption", value: "1994" },
						{ label: "The Godfather", value: "1972" },
						{ label: "The Godfather: Part II", value: "1974" },
						{ label: "The Dark Knight", value: "2008" }
					],
					placeholder: "Placeholder",
				}
			},
			//...other fields
		],
	[]
);

//Option recommended when getting options from a database.
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "dropdown",
				inputSettings: {
					getOptions: myGetOptionsFn,
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldImageUpload
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

`Image Upload` This component helps upload images to the assets library, The setup supports images, videos, or documents
- [**Playground**](/?path=/docs/formfields-formfieldimageupload--playground)
- Data: `object` Optional - Object of the value arguments
	* **imgName** `string` Optional - Image name
	* **size** `number` Optional - Image size
	* **type** `string` Optional - Image type
	* **height** `number` Optional - Image height
	* **width** `number` Optional - Image width
	* **imgCoords** `object` Optional - Image coordinates
		* **x** `number` - X image coordinates
		* **y** `number` - Y image coordinates
- inputSettings:
	* **handleSetFocus** - `() => void` Optional - Callback executed when the set focus button is clicked.
	* **options** - `array` of `object` Optional - List of menu options that can be executed by the component.

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`handleSetFocus`** | `string` | Optional - Callback executed when the set focus button is clicked. |
| **`options`** | `options[]` | Optional - List of menu options that can be executed by the component. |

- options:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`label`** | `string` | Required - Name of the option. |
| **`action`** | `() => void` | Required - Function that will be triggered when the option is clicked |

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "imageUpload",
				inputSettings: {
					handleSetFocus: () => {
						alert("Set focus is called");
					},
					options: [
						{
							label: "Edit",
							action: handleEdit,
						},
						{
							label: "Translate",
							action: handleTranslate,
						}
					]
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldImageVideoLinkDocument
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

`Image Video Link Document Browsing` This component is helpful when the user needs browse an asset from the established assets library for their content.
The setup supports images, videos, documents or links.
- [**Playground**](/?path=/docs/formfields-formfieldimagevideolinkdocumentbrowsing--playground)
- Data: `array` of `object` - Array of a label-value objects that represents an asset.
	* **label** - `number` - Asset property name.
	* **value** - `number` - Asset property value.
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`handleRemove`** | `() => void` | Optional - Callback executed when the remove button is clicked. In order to remove the loaded asset, this function should dispatch a `setFieldValue` form action with a value of an empty array. |
| **`handleSetDocument`** | `() => Promise<void>` | Optional - Callback executed when the document icon clicked. In order to load a document, it should dispatch a form action of type `setFieldValue` with a document of the type specified in the `Data` section. |
| **`handleSetImage`** | `() => Promise<void>` | Required - Callback executed when the image icon clicked. In order to load an image, it should dispatch a form action of type `setFieldValue` with an image of the type specified in the `Data` section. |
| **`handleSetVideo`** | `() => Promise<void>` | Optional - Callback executed when the video icon is clicked. In order to load a video, it should dispatch a form action of type `setFieldValue` with a video of the type specified in the `Data` section. |
| **`handleSetLink`** | `() => Promise<void>` | Optional - Callback executed when the link icon is clicked. In order to load a link, it should dispatch a form action of type `setFieldValue` with a link of the type specified in the `Data` section. |
| **`src`** | `string` | Optional - If the asset contains an image, its source should be passed via this src prop. |
| **`options`** | `options[]` | Optional - List of options that will be shown when the three vertical dots icon is clicked. |

- options:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`label`** | `string` | Required - Name of the option. |
| **`action`** | `() => void` | Required - Function that will be triggered when the option is clicked |

### How to use in a form?
```ts
import formActions from "@simpleview/sv-mosaic/formActions";

const { dispatch } = useForm();

const image = [
	{
		label: "Title",
		value: "Video Thumbnail - YouTube - Visit Santa Fe, New Mexico Video Thumbnail",
	},
	{
		label: "Type",
		value: "Image Video Thumbnail",
	},
	{
		label: "Alt",
		value: "-",
	},
	{
		label: "Size",
		value: "1280x720",
	},
	{
		label: "Focus",
		value: "No",
	},
	{
		label: "Locales",
		value: "-",
	},
];

const video = [
	{
		label: "Title",
		value: "Video Example - This is a video example",
	},
	{
		label: "Type",
		value: "Video",
	},
	{
		label: "Alt",
		value: "-",
	},
	{
		label: "Size",
		value: "1280x720",
	},
	{
		label: "Locales",
		value: "es, en & in",
	},
];

const document = [
	{
		label: "Title",
		value: "Document example",
	},
	{
		label: "Type",
		value: "Document",
	},
	{
		label: "Size",
		value: "333 bytes",
	},
	{
		label: "Size on disk",
		value: "0 bytes",
	},
];

const link = [
	{
		label: "Title",
		value: "Video Thumbnail - YouTube - Visit Santa Fe, New Mexico",
	},
	{
		label: "Type",
		value: "Asset Library - Image",
	},
	{
		label: "URL",
		value: "https://assets.simpleviewinc.com/simpleview/image/upload/v1/clients/santafenm/maxresdefault_97d9460d-0bb1-4870-9be8-2b9af118360e.jpg",
	},
];

const setImage = async () => {
	await dispatch(
		formActions.setFieldValue({
			name: "imageVideoDocumentLink",
			value: image,
			touched: true
		})
	);
};

const setVideo = async () => {
	await dispatch(
		formActions.setFieldValue({
			name: "imageVideoDocumentLink",
			value: video,
			touched: true
		})
	);
};

const setDocument = async () => {
	await dispatch(
		formActions.setFieldValue({
			name: "imageVideoDocumentLink",
			value: document,
			touched: true
		})
	);
};

const setLink = async () => {
	await dispatch(
		formActions.setFieldValue({
			name: "imageVideoDocumentLink",
			value: link,
			touched: true
		})
	);
};

const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				name: "imageVideoDocumentLink",
				type: "imageVideoDocumentLink",
				inputSettings: {
					options: [
						{
							label: "Edit",
							action: handleEdit,
						},
						{
							label: "Translate",
							action: handleTranslate,
						},
					],
					handleSetImage: setImage,
					handleSetDocument: setDocument,
					handleSetVideo: setVideo,
					handleSetLink: setLink,
					handleRemove: removeAsset,
					src: "http://res.cloudinary.com/simpleview/image/upload/v1542821844/clients/grandrapids/_OD_0354_c78fbb66-c75a-4804-9430-9af38ed8e9d5.jpg"
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldMatrix
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

`Matrix` This component is used to dynamically create content in a data view. Some examples may be creating rows using a form fields or displaying
selected rows from another Data View.
- Data: [`MosaicObject[]`](#mosaicobject-type) - Array of objects containing all data required to popoulate the list
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`dataView`** | `DataViewProps` | Data view configurations (see [DataView props](https://simpleviewinc.github.io/sv-mosaic/master/?path=/docs/components-dataview-readme--page#props)).|
| **`buttons`** | `ButtonAttrs[]` | List of buttons that will be display above the data view (see [ButtonAttrs type](#buttonattrs-type)). |

### How to use in a form?
```ts
import formActions from "@simpleview/sv-mosaic/formActions";

const { dispatch } = useForm();

const listColumns = [
	{
		name: "id",
		label: "ID"
	},
	{
		name: "description",
		label: "Description"
	},
	{
		name: "title",
		label: "Title",
	},
];

const gridConfig: DataViewProps = {
	columns: listColumns,
	primaryActions: [
		{
			name: "edit",
			color: "black",
			variant: "icon",
			mIcon: CreateIcon,
			onClick: function ({ data }) {
				alert(`EDIT ${data.id}`);
			}
		},
		{
			name: "delete",
			color: "black",
			variant: "icon",
			mIcon: DeleteIcon,
			onClick: function ({ data }) {
				alert(`EDIT ${data.id}`);
			}
		}
	],
	sticky: true,
	data: state.data.formMatrix,
	limit: 25,
	onReorder: async (newRows) => {
		const rows = newRows.map(row => state.data.formMatrix.find(element => element.id === row));

		await dispatch(
			formActions.setFieldValue({
				name: "formMatrix",
				value: rows,
				touched: true
			})
		);
	},
	display: "list",
	activeColumns: ["id", "description", "title"],
	savedView: defaultView
};

const addRow = async () => {
	const mappedData = rawData.slice(1, 4).map((data) => {
		// convert the date columns to dates, since they are ISOStrings in the file
		return {
			...data,
			created: data.created ? new Date(data.created) : undefined,
			updated: data.updated ? new Date(data.updated) : undefined
		}
	});

	await dispatch(
		formActions.setFieldValue({
			name: "formMatrix",
			value: mappedData,
			touched: true
		})
	);
};


const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				name: "formMatrix",
				type: "matrix",
				inputSettings: {
						dataView: gridConfig,
						buttons: [
							{
								label: "Add",
								onClick: addRow,
								color: "teal",
								variant: "text",
								mIcon: AddIcon
							},
						] as ButtonProps[]
					},
			},
			//...other fields
		],
	[gridConfig]
);
```

## FormFieldMapCoordinates
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- `Map Coordinates` This component is helpful when the user needs browse coordinates in a map.
- [**Playground**](/?path=/docs/formfields-formfieldmapcoordinates--playground)
- Data: `object` - Object of the value arguments
	* **lat** - `number` - Latitude
	* **lng** - `number` - longitude
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`address`** | `object` | Optional - Address object used to set lat and lng values when using the autocoordinates feature (please see Address section). |
| **`googleMapsApiKey`** | `string` | Required - Google Maps API key needed to consume the Maps JavaScript API and Places API. |
| **`zoom`** | `number` | Optional - Zoom applied to the map. If is not defined the map will be all the way zoomed out. |
| **`initialCenter`** | `MapPosition` | Optional - Latitude and longitude object. If is not defined the map will be positioned at 0,0. |

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "mapCoordinates",
				inputSettings: {
					apiKey: "QWErttyuyi-QWDQWFWEeqwfcQWEwefcwfqwew",
					initialCenter: {
						lat: -3.766925461296721
						lng: -40.54497265625
					},
					address: {
						id: 1,
						address1: "8950 N Oracle Rd",
						city: "Oro Valley",
						postalCode: "85704",
						country: "US",
						state: "AZ",
						types: ["physical", "billing"]
					}
				}
			},
			//...other fields
		],
	[]
);
```

## FormFieldNumberTable
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- [**Playground**](/?path=/story/formfields-formfieldnumbertable--playground)
- Data: `object` - Object that has the row name as key and nested another object with the column name as key and the value corresponds to text field value.
	* **rowName: string** - `object` - Row name is used as key identifier.
		* **columnName: string** - `string` - Value of each text field cell.
- inputSettings:

| Name | Type | Default | Description |
| ---- | ---- | --------| ----------- |
| **`columns`** | `{ name: string; title: string }[]` | | Columns definition. |
| **`columnTotalLabel`** | `string` | "Total" | optional - Default: "Total". Label shown on the column that displays the totals. |
| **`displaySumColumn`** | `boolean` | `true` | optional - Shows or hides the total sums of each column. |
| **`displaySumRow`** | `boolean` | `true` | optional - Shows or hides the total sums of each row. |
| **`numberFormatOptions`** | `Intl.NumberFormatOptions` | | optional - Configuration options for the formatter, see more at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat |
| **`rows`** | `{ name: string; title: string, subtitle?: string }[]` | | Rows definition. |
| **`rowTotalLabel`** | `string` | "Total" | optional - Label shown on the total row. |
| **`topLeftLabel`** | `string` | |  optional - Label placed on the top left table corner i.e the first column. |

### How to use in a form?

```ts
const fields: FieldDef[] = useMemo(
	(): FieldDef[] =>
		[
			//...other fields
			{
				//...all generic field props
				type: "numberTable",
				defaultValue: {
					"2023_02_10": {
						single: "12",
						double: "13",
						queen: "14",
						king: "15",
						suite: "16",
						any: "17",
					},
					"2023_02_11": {
						single: "18",
						double: "19",
						queen: "20",
						king: "21",
						suite: "22",
						any: "23",
					},
					"2023_02_12": {
						single: "12",
						double: "13",
						queen: "14",
						king: "15",
						suite: "16",
						any: "20",
					},
					"2023_02_13": {
						single: "1",
						double: "1",
						queen: "1",
						king: "1",
						suite: "1",
						any: "1",
					},
				},
				inputSettings: {
					rowTotalLabel: "TOTAL",
					columnTotalLabel: "No. Rooms",
					topLeftLabel: "Day",
					rows: [
						{ name: "2023_02_10", title: "Shoulder Before" },
						{ name: "2023_02_11", title: "Day 1", subtitle: "February 11" },
						{ name: "2023_02_12", title: "Day 2" },
						{ name: "2023_02_13", title: "Day 3" },
					],
					columns: [
						{ name: "single", title: "Single" },
						{ name: "double", title: "Double" },
						{ name: "queen", title: "Queen" },
						{ name: "king", title: "King" },
						{ name: "suite", title: "Suite" },
						{ name: "any", title: "Any" },
					]
				},
			},
			//...other fields
		],
	[]
);
```

## FormFieldPhoneSelectionDropdown
This field implements the [**FieldDef**](#generic-field-props-fielddef) interface.

- `FormFieldPhoneSelectionDropdown` component is built over [React-Phone-Input-2](https://www.npmjs.com/package/react-phone-input-2) but with SimpleView brand colors. The phone selection dropdown is useful when you want to allow users to enter the information of phone numbers, is conformed with the selection of the country in the dropdown that contains the country flag, and automatically the prefix and number or characters placeholder are showed.
- [**Playground**](/?path=/docs/formfields-formfieldphoneselectiondropdown--playground)
- Data: `string` - String of the selected options
- inputSettings:

| Name | Type | Description |
| ---- | ---- | ----------- |
| **`autoFormat`** | `boolean` | Optional - Phone formatting according to the country selected. |
| **`country`** | `string` | Optional - Initial country. It must be a country code (e.g., us, mx, etc.). |
| **`value`** | `string` | Optional - Input state value. |

### How to use in a form?
```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
				//...all generic field props,
				type: "phone",
				inputSettings: {
					autoFormat: false,
					country: "mx",
				}
			},
			//...other fields
		],
	[]
);
```
## Form Example

<Preview withSource='none'></Preview>

## Types

### MosaicLabelValue (Type)
* **label** - `string` required
* **value** - `string` required

### MosaicObject (Type)
* **[key: string]** - `unknown` required

### MosaicToggle T (Type)
`boolean | (params: T) => boolean | Array<boolean | (params: T) => boolean>`

### MenuItemProps (Type)
* **label** - `string | JSX Element` required
* **color** - `"red" | "blue" ` optional
* **disabled** - `boolean` optional
* **selected** - `boolean` optional
* **onClick** - `(event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void` required
* **mIcon** - `SvgIconComponent` optional - MUI Icon
* **attrs** - `MosaicObject` optional

### ButtonAttrs (Type)
* **label** - `string | JSX Element` optional
* **className** - `string` optional
* **href** - `string` optional
* **color** - `"black" | "blue" | "lightBlue" | "red" | "yellow" | "teal" | "gray"` required
* **mIcon** - `SvgIconComponent` optional - Any Icon from MUI library.
* **variant** - `"icon" | "outlined" | "contained" | "text"` required
* **size** - `"small" | "medium" | "large"` optional
* **iconPosition** - `"left" | "right"` optional
* **disabled** - `boolean` optional
* **fullWidth** - `boolean` optional
* **tooltip** - `string | JSX Element` optional
* **popover** - `JSX Element` optional
* **menuItems** - `MenuItemProps[]` optional
* **menuContent** - `JSX Element` optional
* **mIconColor** - `string` optional
* **onClick** - `(event: React.MouseEvent<HTMLButtonElement>) => void` optional
* **attrs** - `MosaicObject` optional
* **muiAttrs** - `MosaicObject` optional

### ActionAdditional (Type)
* **show** - [`MosaicToggle`](#MosaicToggle-t-type) optional

### DataViewActionShow (Interface)
* `(val?: {[key: string]: any}): void`

## Validators
All of the following default validators return string (with the error message) or undefined (when no error was found). I

### validateEmail
* Receives: string
* Error message returned: "The value is not a valid email"
* Ways of declaring:
	* "validateEmail"
	* { fn: "validateEmail", options: undefined }

### required
* Receives: string | string[]
* Error message returned: "This field is required, please fill it"
* Ways of declaring:
	* "required"
	* { fn: "required", options: undefined }
	* As a boolean prop for all fields (see [Generic Field Props subsection](#generic-field-props-fielddef))

### validateNumber
* Receives: string
* Error message returned: "The value is not a number"
* Ways of declaring:
	* "validateNumber"
	* { fn: "validateNumber", options: undefined }

### validateURL
* Receives: string
* Error message returned: "The value is not a valid URL"
* Ways of declaring:
	* "validateURL"
	* { fn: "validateURL", options: undefined }

### validateDateRange
- This is the only validator that requires to be added to 2 fields in order to work: the fields serving as start and end date respectively.
- The startDate field will add the name of the endDate field linked to in the options attribute.
- The endDate field will add the name of the startDate field linked to in the options attribute.

* Receives: value: `string`, data: `object` (see data attribute on [State](#state)), options: `MosaicObject`
* Error message returned: "Start date should happen before the end date"
* Ways of declaring:
	* { fn: "validateDateRange", options: { endDateName: "nameOfField" } }
	* { fn: "validateDateRange", options: { startDateName: "nameOfField" } }

```ts
const fields = useMemo(
	() =>
		[
			//...other fields
			{
					name: "startDate",
					type: "date",
					label: "Start date",
					validators: [{ fn: "validateDateRange", options: { endDateName: "endDate" } }],
					inputSettings: {
						showTime: false,
					},
				},
				{
					name: "endDate",
					type: "date",
					label: "End date",
					validators: [{ fn: "validateDateRange", options: { startDateName: "startDate" } }],
					inputSettings: {
						showTime: false,
					},
				},
			//...other fields
		],
	[]
);
```
